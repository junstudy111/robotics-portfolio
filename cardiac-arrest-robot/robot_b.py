#!/usr/bin/env python3
"""
robot_b.py (ì´ë²¤íŠ¸ ê¸°ë°˜ ë¦¬íŒ©í† ë§ - í”Œë˜ê·¸ ì¶”ê°€)
ìƒíƒœ ë¨¸ì‹  ëŒ€ì‹  ì½œë°± ì²´ì¸ ë°©ì‹ìœ¼ë¡œ ë™ì‘
"""

import time
import math
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import Bool, Int32

from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult
from turtlebot4_navigation.turtlebot4_navigator import TurtleBot4Navigator
from tf_transformations import quaternion_from_euler

import tf2_ros
import tf2_msgs.msg
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy, QoSDurabilityPolicy

from irobot_create_msgs.msg import AudioNoteVector, AudioNote
from builtin_interfaces.msg import Duration


# ==========================================
# ì„¤ì • íŒŒë¼ë¯¸í„°
# ==========================================
OFFSET_DISTANCE = 0.6
RESCUE_POSITION = (2.31, -1.36, 270.0)
DOCK_APPROACH_POSITION_ROBOT3 = (-0.42, -0.07, 90.0)
DOCK_APPROACH_POSITION_ROBOT5 = (-1.32, -3.82, 90.0)


class RescueRobotEventBased(Node):
    def __init__(self):
        super().__init__('rescue_b')
        
        self.get_logger().set_level(rclpy.logging.LoggingSeverity.INFO)
        
        # Navigator ì´ˆê¸°í™”
        self.robot3_dock_nav = TurtleBot4Navigator(namespace='robot3')
        self.robot3_nav = BasicNavigator(namespace='robot3')
        
        self.robot5_dock_nav = TurtleBot4Navigator(namespace='robot5')
        self.robot5_nav = BasicNavigator(namespace='robot5')
        
        # TF Buffer
        self.tf_buffer_robot3 = tf2_ros.Buffer(cache_time=rclpy.duration.Duration(seconds=10.0))
        self.tf_buffer_robot5 = tf2_ros.Buffer(cache_time=rclpy.duration.Duration(seconds=10.0))
        
        # TF êµ¬ë…
        static_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            history=QoSHistoryPolicy.KEEP_ALL,
            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,
        )
        
        self.create_subscription(tf2_msgs.msg.TFMessage, '/robot3/tf', self.tf3_callback, 10)
        self.create_subscription(tf2_msgs.msg.TFMessage, '/robot3/tf_static', self.tf3_static_callback, static_qos)
        self.create_subscription(tf2_msgs.msg.TFMessage, '/robot5/tf', self.tf5_callback, 10)
        self.create_subscription(tf2_msgs.msg.TFMessage, '/robot5/tf_static', self.tf5_static_callback, static_qos)
        
        # ìƒíƒœ ë³€ìˆ˜
        self.target_coordinate = None
        self.robot_selected = None
        self.is_moving = False
        self.is_paused = False
        self.current_goal_pose = None
        self.crowd_detected = False
        
        # ì´ë²¤íŠ¸ í”Œë˜ê·¸
        self.mission_started = False
        self.waiting_for_rescue = False
        self.rescue_detected = False
        self.waiting_for_stop = False
        
        # ìƒíƒœ í¼ë¸”ë¦¬ì…”
        self.progress_pub = self.create_publisher(Int32, '/robotB/progress', 10)

        # ğŸ”Š Beep í¼ë¸”ë¦¬ì…” (AudioNoteVector íƒ€ì…ìœ¼ë¡œ!)
        self.beep_pub_robot3 = self.create_publisher(AudioNoteVector, '/robot3/cmd_audio', 10)
        self.beep_pub_robot5 = self.create_publisher(AudioNoteVector, '/robot5/cmd_audio', 10)
        self.beep_timer = None  # âœ… ì´ê±° ì¶”ê°€!
        
        # êµ¬ë…ìë“¤
        qos = QoSProfile(
        depth=10,
        reliability=QoSReliabilityPolicy.RELIABLE,  # ì‹ ë¢°ì„± ë³´ì¥
        )
        self.create_subscription(Bool, '/robot_role', self.robot_select_callback, qos)
        self.create_subscription(PoseStamped, '/patient_pose', self.goal_callback, qos)
        self.create_subscription(Bool, '/robotB/responder_done', self.responder_done_callback, qos)
        self.create_subscription(Bool, '/robot_stop', self.stop_callback, qos)
        self.create_subscription(Bool, '/robotB/crowd_detected', self.crowd_callback, 10)
        
        # íƒ€ì´ë¨¸ (ë„¤ë¹„ê²Œì´ì…˜ ì™„ë£Œ ì²´í¬ìš©ë§Œ)
        self.create_timer(0.5, self.check_navigation_status)
        
        self.get_logger().info("âœ… RescueRobot ì´ˆê¸°í™” ì™„ë£Œ (ì´ë²¤íŠ¸ ê¸°ë°˜)")
        
    # ==========================================
    # TF ì½œë°±ë“¤
    # ==========================================
    def tf3_callback(self, msg):
        for t in msg.transforms:
            self.tf_buffer_robot3.set_transform(t, 'default_authority')
    
    def tf3_static_callback(self, msg):
        for t in msg.transforms:
            self.tf_buffer_robot3.set_transform(t, 'default_authority')
    
    def tf5_callback(self, msg):
        for t in msg.transforms:
            self.tf_buffer_robot5.set_transform(t, 'default_authority')
    
    def tf5_static_callback(self, msg):
        for t in msg.transforms:
            self.tf_buffer_robot5.set_transform(t, 'default_authority')
    
    # ==========================================
    # ì´ë²¤íŠ¸ ì½œë°±ë“¤
    # ==========================================
    def robot_select_callback(self, msg: Bool):
        """ë¡œë´‡ ì„ íƒ ì´ë²¤íŠ¸"""
        if self.mission_started:
            return
        
        self.robot_selected = 'robot5' if msg.data else 'robot3'
        self.get_logger().info(f"ğŸ¤– ë¡œë´‡ ì„ íƒ: {self.robot_selected}")
        self.try_start_mission()

    def goal_callback(self, msg: PoseStamped):
        """ëª©í‘œ ì¢Œí‘œ ìˆ˜ì‹  ì´ë²¤íŠ¸"""
        if self.mission_started:
            return
        
        self.target_coordinate = (msg.pose.position.x, msg.pose.position.y)
        self.get_logger().info(f"ğŸ“ ëª©í‘œ ì¢Œí‘œ: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})")
        self.try_start_mission()
    
    def responder_done_callback(self, msg: Bool):
        """êµ¬ê¸‰ëŒ€ì› ë°œê²¬ ì´ë²¤íŠ¸"""  
        if msg.data and self.waiting_for_rescue:
            self.get_logger().info("ğŸš‘ êµ¬ê¸‰ëŒ€ì› ë°œê²¬! 2ì°¨ ì´ë™ ì‹œì‘")
            self.rescue_detected = True
            self.waiting_for_rescue = False
            
            # ì ì‹œ ëŒ€ê¸° í›„ ëª©í‘œë¡œ ë³µê·€
            self._rescue_timer = self.create_timer(1.0, self.move_to_target_second)
    
    def stop_callback(self, msg: Bool):
        """ì¤‘ë‹¨ ëª…ë ¹ ì´ë²¤íŠ¸ (ë¯¸ì…˜ ì¤‘ ì–¸ì œ ì–´ë””ì„œë‚˜ ë°œìƒ ê°€ëŠ¥)"""
        # ë¯¸ì…˜ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ê±°ë‚˜, ì´ë¯¸ ì¤‘ë‹¨ ëª…ë ¹ì„ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
        if not self.mission_started or not msg.data:
            return

        self.get_logger().warn("ğŸ›‘ ê¸´ê¸‰ ì¤‘ë‹¨ ëª…ë ¹ ìˆ˜ì‹ ! ì¦‰ì‹œ ë„í‚¹ ìŠ¤í…Œì´ì…˜ìœ¼ë¡œ ë³µê·€í•©ë‹ˆë‹¤.")
        
        # 1. ì§„í–‰ ì¤‘ì¸ ëª¨ë“  ë„¤ë¹„ê²Œì´ì…˜ ì¦‰ì‹œ ì·¨ì†Œ
        nav, _, _ = self.get_current_navigator()
        if self.is_moving:
            nav.cancelTask()
            self.is_moving = False
        
        # 2. ëª¨ë“  ëŒ€ê¸° ìƒíƒœ/ì´ë²¤íŠ¸ í”Œë˜ê·¸ ë¬´ë ¥í™” (ë„í‚¹ ë°©í•´ ê¸ˆì§€)
        self.waiting_for_rescue = False
        self.waiting_for_stop = False
        
        # 3. ë„¤ë¹„ê²Œì´ì…˜ ì½œë°± ë¬´íš¨í™”
        self._nav_complete_callback = None
        
        # 4. ëª¨ë“  ì§„í–‰ ì¤‘ì¸ íƒ€ì´ë¨¸ ì·¨ì†Œ
        self.cancel_all_timers()
        
        # 5. ë¹„í”„ìŒ ì¤‘ì§€
        self.stop_beep()

        # 6. ë„í‚¹ìœ¼ë¡œ ì´ë™ ì‹¤í–‰
        # ê¸°ì¡´ íƒ€ì´ë¨¸ë‚˜ ì½œë°±ì´ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì ì‹œ í›„ ì´ë™ ì‹¤í–‰
        self.create_timer(0.5, self.move_to_dock)

    def cancel_all_timers(self):
        """ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ íƒ€ì´ë¨¸ ì·¨ì†Œ"""
        timer_attrs = [
            '_safety_timer',
            '_first_arrival_timer', 
            '_rescue_timer',
            '_second_arrival_timer',
            '_undock_timer',  # â† ì¶”ê°€
            '_dock_timer'      # â† ì¶”ê°€
        ]
        
        for attr in timer_attrs:
            if hasattr(self, attr):
                timer = getattr(self, attr)
                if timer is not None:
                    timer.cancel()
                    self.get_logger().info(f"â¹ï¸ {attr} ì·¨ì†Œë¨")
    
    def crowd_callback(self, msg: Bool):
        """í† í”½ ë°›ìë§ˆì ì¦‰ì‹œ ì²˜ë¦¬"""
        self.crowd_detected = msg.data
        
        # âœ… is_moving ë˜ëŠ” is_paused ìƒíƒœì¼ ë•Œë§Œ ì²˜ë¦¬
        if not (self.is_moving or self.is_paused):
            return
        
        nav, _, _ = self.get_current_navigator()
        
        if self.crowd_detected and not self.is_paused:
            self.is_paused = True
            self.is_moving = False  # âœ… ì¶”ê°€
            nav.cancelTask()
            self.get_logger().warn("ğŸ›‘ êµ°ì¤‘ ê°ì§€! ì •ì§€")
        
        elif not self.crowd_detected and self.is_paused:
            self.is_paused = False
            self.is_moving = True
            
            if self.current_goal_pose is not None:
                nav.goToPose(self.current_goal_pose)
                self.get_logger().info("âœ… êµ°ì¤‘ í•´ì†Œ! ì¬ê°œ")
    # ==========================================
    # Beep ê´€ë ¨ í•¨ìˆ˜ë“¤
    # ==========================================
    def create_beep_message(self):          
        """Beep ë©”ì‹œì§€ ìƒì„±"""
        msg = AudioNoteVector()
        msg.append = False
        
        # ì§§ì€ ì‚ ì†Œë¦¬ (880Hz, 0.1ì´ˆ)
        note = AudioNote()
        note.frequency = 880
        note.max_runtime = Duration(sec=0, nanosec=100000000)
        
        msg.notes = [note]
        return msg
    
    def start_beep(self):
        """Beep ì‹œì‘ (0.5ì´ˆ ê°„ê²©)"""
        if self.beep_timer is None:
            self.beep_timer = self.create_timer(0.5, self.beep_callback)
            self.get_logger().info("ğŸ”Š Beep ì‹œì‘")
    
    def stop_beep(self):
        """Beep ì¤‘ì§€"""
        if self.beep_timer is not None:
            self.beep_timer.cancel()
            self.beep_timer = None
            self.get_logger().info("ğŸ”‡ Beep ì¤‘ì§€")
    
    def beep_callback(self):
        """Beep ì†Œë¦¬ ë°œí–‰"""
        msg = self.create_beep_message()
        
        if self.robot_selected == 'robot5':
            self.beep_pub_robot5.publish(msg)
        else:
            self.beep_pub_robot3.publish(msg)
    
    # ==========================================
    # ë¯¸ì…˜ ì‹œì‘ íŠ¸ë¦¬ê±°
    # ==========================================
    def try_start_mission(self):
        """ë¡œë´‡ ì„ íƒ + ëª©í‘œ ì¢Œí‘œê°€ ëª¨ë‘ ìˆìœ¼ë©´ ë¯¸ì…˜ ì‹œì‘"""
        if not self.mission_started and self.robot_selected and self.target_coordinate:
            self.mission_started = True
            self.get_logger().info("âœ… ë¯¸ì…˜ ì‹œì‘!")
            self.start_undocking()
    
    # ==========================================
    # ë‹¨ê³„ë³„ ë™ì‘ í•¨ìˆ˜ë“¤
    # ==========================================
    def start_undocking(self):
        """1ë‹¨ê³„: ì–¸ë„í‚¹"""
        self.publish_progress(0)
        
        _, dock_nav, namespace = self.get_current_navigator()
        
        if dock_nav.getDockedStatus():
            self.get_logger().info(f"ğŸ”“ [{namespace}] ì–¸ë„í‚¹ ì‹œì‘")
            dock_nav.undock()
            
            # ì–¸ë„í‚¹ ì™„ë£Œ ëŒ€ê¸°
            self._undock_timer = self.create_timer(1.0, self.check_undock_complete)
        else:
            self.get_logger().info("ì´ë¯¸ ì–¸ë„í‚¹ ìƒíƒœ")
            self.on_undock_complete()
    
    def check_undock_complete(self):
        """ì–¸ë„í‚¹ ì™„ë£Œ ì²´í¬"""
        _, dock_nav, _ = self.get_current_navigator()
        
        if not dock_nav.getDockedStatus():
            self.get_logger().info("âœ… ì–¸ë„í‚¹ ì™„ë£Œ!")
            
            # âœ… íƒ€ì´ë¨¸ ì·¨ì†Œ
            if hasattr(self, '_undock_timer'):
                self._undock_timer.cancel()
                delattr(self, '_undock_timer')
            
            self.on_undock_complete()
    
    def on_undock_complete(self):
        """ì–¸ë„í‚¹ ì™„ë£Œ â†’ ì•ˆì „ì„ ìœ„í•´ 50cm ì§ì§„ ë‹¨ê³„ ì¶”ê°€"""
        if hasattr(self, '_undock_complete_done'):
            return
        self._undock_complete_done = True
        
        self.get_logger().info("âœ… ì–¸ë„í‚¹ ì™„ë£Œ! ì•ˆì „ ì§ì§„(50cm) ì‹œì‘")
        
        # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì „ë°© 50cm ì¢Œí‘œ ê³„ì‚° í›„ ì´ë™
        self.move_forward_safety(0.5)

    def move_forward_safety(self, distance):
        """ì¶œë°œ ì „ ì¥ì• ë¬¼ ê°„ì„­ ë°©ì§€ë¥¼ ìœ„í•œ ì§§ì€ ì§ì§„"""
        try:
            tf_buffer = self.get_current_tf_buffer()
            transform = tf_buffer.lookup_transform(
                'map', 'base_link', rclpy.time.Time(seconds=0),
                timeout=rclpy.duration.Duration(seconds=5.0)
            )
            
            curr_x = transform.transform.translation.x
            curr_y = transform.transform.translation.y
            
            # í˜„ì¬ ë¡œë´‡ì´ ë°”ë¼ë³´ëŠ” ë°©í–¥(Yaw) ì¶”ì¶œ
            from tf_transformations import euler_from_quaternion
            q = transform.transform.rotation
            _, _, curr_yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])
            
            # ì „ë°© distance ë§Œí¼ì˜ ì¢Œí‘œ ê³„ì‚°
            safety_x = curr_x + distance * math.cos(curr_yaw)
            safety_y = curr_y + distance * math.sin(curr_yaw)
            safety_yaw_deg = math.degrees(curr_yaw)
            
            self.get_logger().info(f"ğŸš€ ì•ˆì „ ê±°ë¦¬ í™•ë³´ ì¤‘: {distance}m ì „ì§„")
            self.send_navigation_goal(safety_x, safety_y, safety_yaw_deg, 
                                    callback=self.move_to_target_first)
        except Exception as e:
            self.get_logger().error(f"âŒ ì•ˆì „ ì§ì§„ ê³„ì‚° ì‹¤íŒ¨: {e}")
            # ì‹¤íŒ¨ ì‹œ ì•ˆì „ì„ ìœ„í•´ ì ì‹œ ëŒ€ê¸° í›„ ë°”ë¡œ ëª©í‘œ ì´ë™
            self._safety_timer = self.create_timer(3.0, self.move_to_target_first)
    
    def move_to_target_first(self):
        """2ë‹¨ê³„: 1ì°¨ ëª©í‘œë¡œ ì´ë™"""
        if hasattr(self, '_first_move_started'):
            return
        self._first_move_started = True
        
        self.publish_progress(1)
        
        target_x, target_y = self.target_coordinate
        approach_x, approach_y, approach_yaw = self.calculate_approach_position(
            target_x, target_y, OFFSET_DISTANCE
        )
        
        self.get_logger().info("ğŸ¯ [1ì°¨] ëª©í‘œë¡œ ì´ë™ ì‹œì‘")
        self.start_beep()  # ğŸ”Š
        self.send_navigation_goal(approach_x, approach_y, approach_yaw, 
                                 callback=self.on_first_arrival)
    
    def on_first_arrival(self):
        """1ì°¨ ë„ì°© ì™„ë£Œ â†’ rescue_positionìœ¼ë¡œ"""
        if hasattr(self, '_first_arrival_done'):
            return
        self._first_arrival_done = True
        self.get_logger().info("âœ… 1ì°¨ ëª©í‘œ ë„ì°©!")
        
        # 5ì´ˆ ëŒ€ê¸° í›„ rescue_positionìœ¼ë¡œ
        self._first_arrival_timer = self.create_timer(5.0, self.move_to_rescue_position)

    
    def move_to_rescue_position(self):
        """3ë‹¨ê³„: rescue_positionìœ¼ë¡œ ì´ë™"""
        if hasattr(self, '_rescue_move_started'):
            return
        self._rescue_move_started = True
        
        self.publish_progress(2)
        
        x, y, yaw = RESCUE_POSITION
        self.get_logger().info("ğŸ¥ Rescue positionìœ¼ë¡œ ì´ë™")
        
        self.send_navigation_goal(x, y, yaw, callback=self.on_rescue_position_arrival)
    
    def on_rescue_position_arrival(self):
        """rescue_position ë„ì°© â†’ êµ¬ê¸‰ëŒ€ì› ëŒ€ê¸°"""
        if hasattr(self, '_rescue_arrival_done'):
            return
        self._rescue_arrival_done = True
        
        self.get_logger().info("âœ… Rescue position ë„ì°©! êµ¬ê¸‰ëŒ€ì› ëŒ€ê¸° ì¤‘...")
        self.publish_progress(3)
        
        self.waiting_for_rescue = True
        self.rescue_detected = False
    
    def move_to_target_second(self):
        """4ë‹¨ê³„: 2ì°¨ ëª©í‘œë¡œ ì´ë™"""
        if hasattr(self, '_second_move_started'):
            return
        self._second_move_started = True
        
        self.publish_progress(4)
        
        target_x, target_y = self.target_coordinate
        approach_x, approach_y, approach_yaw = self.calculate_approach_position(
            target_x, target_y, OFFSET_DISTANCE
        )
        
        self.get_logger().info("ğŸ¯ [2ì°¨] ëª©í‘œë¡œ ì¬ì´ë™")
        self.send_navigation_goal(approach_x, approach_y, approach_yaw,
                                 callback=self.on_second_arrival)
    
    def on_second_arrival(self):
        """2ì°¨ ë„ì°© ì™„ë£Œ â†’ ì¤‘ë‹¨ ëŒ€ê¸°"""
        if hasattr(self, '_second_arrival_done'):
            return
        self._second_arrival_done = True
        self.stop_beep()  # ğŸ”‡
        
        self.get_logger().info("âœ… 2ì°¨ ëª©í‘œ ë„ì°©! ì¤‘ë‹¨ ëª…ë ¹ ëŒ€ê¸° ì¤‘...")
        
        self.waiting_for_stop = True
    
    def move_to_dock(self):
        """5ë‹¨ê³„: ë„í‚¹ ìŠ¤í…Œì´ì…˜ìœ¼ë¡œ (ì–´ëŠ ë‹¨ê³„ì—ì„œë“  ì§„ì… ê°€ëŠ¥í•˜ë„ë¡ í”Œë˜ê·¸ ì²´í¬ ì œê±°)"""
        # ì´ë¯¸ ë„í‚¹ ì¤‘ì´ë©´ ë‹¤ì‹œ í˜¸ì¶œë˜ì§€ ì•Šê²Œ ë°©ì§€
        if hasattr(self, '_dock_move_started') and self._dock_move_started:
            return
        self._dock_move_started = True
        
        # âš ï¸ ë¯¸ì…˜ ë‹¨ê³„ í¼ë¸”ë¦¬ì‹œ (ë„í‚¹ ë³µê·€ ìƒíƒœ)
        self.publish_progress(5)
        
        _, _, namespace = self.get_current_navigator()
        
        if namespace == 'robot5':
            dock_x, dock_y, dock_yaw = DOCK_APPROACH_POSITION_ROBOT5
        else:
            dock_x, dock_y, dock_yaw = DOCK_APPROACH_POSITION_ROBOT3
        
        self.get_logger().info("ğŸš‰ ë„í‚¹ ìŠ¤í…Œì´ì…˜ìœ¼ë¡œ ë³µê·€ ì‹œì‘")
        self.send_navigation_goal(dock_x, dock_y, dock_yaw, callback=self.start_docking)
    
    def start_docking(self):
        """6ë‹¨ê³„: ë„í‚¹"""
        if hasattr(self, '_docking_started'):
            return
        self._docking_started = True
        
        self.publish_progress(0)
        
        _, dock_nav, _ = self.get_current_navigator()
        
        self.get_logger().info("ğŸ”Œ ë„í‚¹ ì‹œì‘")
        dock_nav.dock()
        
        # âœ… íƒ€ì´ë¨¸ ì €ì¥
        self._dock_timer = self.create_timer(1.0, self.check_dock_complete)

    def check_dock_complete(self):
        """ë„í‚¹ ì™„ë£Œ ì²´í¬"""
        _, dock_nav, _ = self.get_current_navigator()
        
        if dock_nav.getDockedStatus():
            self.get_logger().info("âœ… ë„í‚¹ ì™„ë£Œ!")
            
            # âœ… íƒ€ì´ë¨¸ ì·¨ì†Œ
            if hasattr(self, '_dock_timer'):
                self._dock_timer.cancel()
                delattr(self, '_dock_timer')
            
            self.on_mission_complete()
    
    def on_mission_complete(self):
        """ë¯¸ì…˜ ì™„ë£Œ â†’ ë¦¬ì…‹"""
        if hasattr(self, '_mission_complete_done'):
            return
        self._mission_complete_done = True
        
        self.get_logger().info("âœ… ===== ë¯¸ì…˜ ì™„ë£Œ! =====")
        self.publish_progress(0)
        
        # 3ì´ˆ í›„ ë¦¬ì…‹
        self.create_timer(3.0, self.reset_mission)
    
    # ==========================================
    # ë„¤ë¹„ê²Œì´ì…˜ ê´€ë ¨
    # ==========================================
    def send_navigation_goal(self, x, y, yaw_degrees, callback=None):
        """ë„¤ë¹„ê²Œì´ì…˜ ëª©í‘œ ì „ì†¡"""
        nav, _, _ = self.get_current_navigator()
        
        self.current_goal_pose = self.create_pose_stamped(x, y, yaw_degrees)
        self.is_moving = True
        self.is_paused = False
        self._nav_complete_callback = callback
        
        nav.goToPose(self.current_goal_pose)
        self.get_logger().info(f"ğŸš€ ì´ë™ ì‹œì‘: ({x:.2f}, {y:.2f}, {yaw_degrees:.1f}Â°)")
    
    def check_navigation_status(self):
        """ë„¤ë¹„ê²Œì´ì…˜ ì™„ë£Œ ì²´í¬ (íƒ€ì´ë¨¸)"""
        if not self.is_moving:
            return
        
        nav, _, _ = self.get_current_navigator()
        
        if nav.isTaskComplete():
            result = nav.getResult()
            self.is_moving = False
            
            if result == TaskResult.SUCCEEDED:
                self.get_logger().info("âœ… ë„¤ë¹„ê²Œì´ì…˜ ì„±ê³µ!")
                
                # ì½œë°± ì‹¤í–‰
                if self._nav_complete_callback:
                    callback = self._nav_complete_callback
                    self._nav_complete_callback = None
                    callback()
            else:
                self.get_logger().error(f"âŒ ë„¤ë¹„ê²Œì´ì…˜ ì‹¤íŒ¨: {result}")
    
    # ==========================================
    # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
    # ==========================================
    def get_current_navigator(self):
        if self.robot_selected == 'robot5':
            return self.robot5_nav, self.robot5_dock_nav, 'robot5'
        else:
            return self.robot3_nav, self.robot3_dock_nav, 'robot3'
    
    def get_current_tf_buffer(self):
        return self.tf_buffer_robot5 if self.robot_selected == 'robot5' else self.tf_buffer_robot3
    
    def create_pose_stamped(self, x, y, yaw_degrees):
        nav, _, _ = self.get_current_navigator()
        
        goal = PoseStamped()
        goal.header.frame_id = 'map'
        goal.header.stamp = nav.get_clock().now().to_msg()
        goal.pose.position.x = x
        goal.pose.position.y = y
        goal.pose.position.z = 0.0
        
        yaw_rad = math.radians(yaw_degrees)
        q = quaternion_from_euler(0, 0, yaw_rad)
        goal.pose.orientation.x = q[0]
        goal.pose.orientation.y = q[1]
        goal.pose.orientation.z = q[2]
        goal.pose.orientation.w = q[3]
        
        return goal
    
    def calculate_approach_position(self, target_x, target_y, offset_distance):
        try:
            tf_buffer = self.get_current_tf_buffer()
            transform = tf_buffer.lookup_transform(
                'map', 'base_link', rclpy.time.Time(seconds=0),
                timeout=rclpy.duration.Duration(seconds=5.0)
            )
            
            robot_x = transform.transform.translation.x
            robot_y = transform.transform.translation.y
            
            dx = target_x - robot_x
            dy = target_y - robot_y
            yaw_to_target = math.atan2(dy, dx)
            
            approach_x = target_x - offset_distance * math.cos(yaw_to_target)
            approach_y = target_y - offset_distance * math.sin(yaw_to_target)
            approach_yaw_deg = math.degrees(yaw_to_target)
            
            return approach_x, approach_y, approach_yaw_deg
        except Exception as e:
            self.get_logger().error(f"âŒ ì ‘ê·¼ ìœ„ì¹˜ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return target_x, target_y, 0.0
    
    def publish_progress(self, state_code):
        msg = Int32()
        msg.data = state_code
        self.progress_pub.publish(msg)
    
    def reset_mission(self):
        """ë¯¸ì…˜ ë¦¬ì…‹"""
        if hasattr(self, '_reset_started'):
            return
        self._reset_started = True
        
        self.get_logger().info("ğŸ”„ ë¯¸ì…˜ ë¦¬ì…‹...")
        self.stop_beep()
        
        # âœ… ëª¨ë“  íƒ€ì´ë¨¸ í•œ ë²ˆì— ì •ë¦¬!
        self.cancel_all_timers()
        
        # ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”
        self.target_coordinate = None
        self.robot_selected = None
        self.is_moving = False
        self.is_paused = False
        self.current_goal_pose = None
        self.mission_started = False
        self.waiting_for_rescue = False
        self.rescue_detected = False
        self.waiting_for_stop = False
        self._nav_complete_callback = None
        
        # í”Œë˜ê·¸ë“¤ ì´ˆê¸°í™”
        for attr in ['_undock_complete_done', '_first_move_started', '_first_arrival_done',
                    '_rescue_move_started', '_rescue_arrival_done', '_second_move_started',
                    '_second_arrival_done', '_dock_move_started', '_docking_started',
                    '_mission_complete_done', '_reset_started']:
                if hasattr(self, attr):
                    delattr(self, attr)


def main():
    rclpy.init()
    node = RescueRobotEventBased()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
